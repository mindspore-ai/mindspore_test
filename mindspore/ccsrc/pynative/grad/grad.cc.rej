diff a/mindspore/ccsrc/pynative/grad/grad.cc b/mindspore/ccsrc/pynative/grad/grad.cc	(rejected hunks)
@@ -826,10 +826,6 @@ void GradExecutor::MakeNewTopCell(const InputArgsInfoPtr &input_args_info) {
       (new_top_cell_is_pipeline_high_order || top_cell_->grad_is_running())) {
     PushTopCellStack(top_cell_);
   }
-  if (top_cell_ != nullptr && top_cell_->grad_is_running()) {
-    MS_LOG(DEBUG) << "Push inner top cell";
-    PushTopCellStack(top_cell_);
-  }
 
   const auto &obj_id_with_grad_order = GetAlreadyRunCellId(input_args_info->obj_id);
   MS_LOG(DEBUG) << "Get obj id with grad order " << obj_id_with_grad_order;
@@ -1009,31 +1005,15 @@ void GradExecutor::EndGraphImpl(const InputArgsInfoPtr &input_args_info) {
   }
   top_input_args_info_ = input_args_info;
   forward()->ClearNodeAbsMap();
-  top_cell_->set_has_construct_graph(true);
   auto cur_top_cell = top_cell_;
-  TopCellInfoPtr  normal_cell = nullptr;
   if (input_args_info->is_inner_grad_topest_cell) {
     MS_LOG(DEBUG) << "cur innner top cell: " << input_args_info->cell_id;
     top_cell_->ResetMetaGradInfo();
     top_cell_ = PopTopCellStack();
-    MS_EXCEPTION_IF_NULL(top_cell_);
     top_cell_->ResumeMetaGradInfo();
   } else if (cur_top_cell->is_pipeline_top_cell() && !cur_top_cell->is_high_order_top_cell() &&
              !pipeline_top_cell_map_[input_args_info->already_run_cell_id].front()->inner_has_high_order()) {
     (void)PopTopCellStack();
-  } else {
-    MS_LOG(DEBUG) << "Normal pop";
-    normal_cell = top_cell_stack_.top();
-    (void)PopTopCellStack();
-  }
-  if (!top_cell_stack_.empty() && top_cell_stack_.top()->grad_is_running()) {
-    top_cell_->ResetMetaGradInfo();
-    top_cell_ = top_cell_stack_.top();
-    top_cell_->ResumeMetaGradInfo();
-    (void)PopTopCellStack();
-  }
-  if (normal_cell != nullptr) {
-    PushTopCellStack(normal_cell);
   }
   MS_LOG(DEBUG) << "Cur top last cell " << input_args_info->cell_id;
 }
@@ -1223,10 +1203,6 @@ py::object GradExecutor::RunGrad(const prim::GradOperationPtr &grad, const py::o
   runtime::Pipeline::Get().WaitAll();
 
   RegBackpropStageHook(true);
-  TopCellInfoPtr forward_top_cell = nullptr;
-  if (top_cell_ != nullptr && !top_cell_->has_construct_graph()) {
-    forward_top_cell = top_cell_;
-  }
   GetTopCellWithInputArgsRespectTo(grad, obj, args);
   MS_EXCEPTION_IF_NULL(top_cell_);
   MS_LOG(DEBUG) << "Run top cell " << top_cell_;
@@ -1281,9 +1257,6 @@ py::object GradExecutor::RunGrad(const prim::GradOperationPtr &grad, const py::o
   }
   auto ret = RunGradFunc(grad_attr, w_args, p_args, has_aux_val);
   RegBackpropStageHook(false);
-  if (forward_top_cell != nullptr) {
-    top_cell_ = forward_top_cell;
-  }
   return ret;
 }
 
@@ -1617,13 +1590,8 @@ py::object GradExecutor::CheckAlreadyRun(const prim::GradOperationPtr &grad, con
   // same. GradOperation information includes grad order for distinguish high-order.
   // Use a flag: call_grad_api_first_ for distinguish these two scenarios. If scenarios 1 are taken,
   // call_grad_api_first_ will not take effect, otherwise, it works.
-  bool high_order = py::cast<bool>(keep_graph);
-  bool neee_increase_grad_order = false;
-  if (!high_order) {
-    grad_order_ = 1;
-  } else {
-    neee_increase_grad_order = NeedIncreaseGradOrder(obj_id);
-  }
+  bool neee_increase_grad_order = NeedIncreaseGradOrder(obj_id);
+
   // Include grad position
   std::string grad_position_str;
   if (!py::isinstance<py::none>(grad_position)) {
@@ -1704,10 +1672,7 @@ py::object GradExecutor::RunGradFunc(const autograd::GradAttr &grad_attr,
   std::string swap_grad_operation;
   std::swap(grad_operation_, swap_grad_operation);
   auto cur_top_cell = top_cell_;
-  auto pre_grad_flag = GradState::Get().grad_flag();
-  GradState::Get().set_grad_flag(false);
   auto grads = auto_grad_cell->Finish(w_args, p_args, grad_attr, has_aux, sens);
-  GradState::Get().set_grad_flag(pre_grad_flag);
   top_cell_ = cur_top_cell;
   std::swap(grad_operation_, swap_grad_operation);
   MS_EXCEPTION_IF_NULL(grads);
@@ -1934,8 +1899,7 @@ void GradExecutor::ClearGlobalRes() const {
 void GradExecutor::ClearGradRes() {
   MS_LOG(DEBUG) << "Top cell run finish " << top_cell_ << " and its shadow top cell " << top_cell_->shadow_top_cell();
   // Pop the current top cell on stack
-  if (!top_cell_->is_pipeline_top_cell() && !top_cell_stack_.empty() &&
-      top_cell_.get() == top_cell_stack_.top().get()) {
+  if (!top_cell_->is_pipeline_top_cell()) {
     (void)PopTopCellStack();
   }
 
