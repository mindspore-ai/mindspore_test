apply_adagrad:
    description: |
        Updates relevant entries according to the adagrad scheme.
        The Adagrad algorithm was proposed in
        `Adaptive Subgradient Methods for Online Learning and Stochastic Optimization
        <http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf>`_.
        This module can adaptively assign different learning rates for each parameter in view of the uneven number
        of samples for different parameters.

        .. math::
            \begin{array}{ll} \\
                accum += grad * grad \\
                var -= lr * grad * \frac{1}{\sqrt{accum}}
            \end{array}

        Inputs of `var`, `accum` and `grad`  comply with the implicit type conversion rules
        to make the data types consistent.
        If they have different data types, the lower priority data type will be converted to
        the relatively highest priority data type.

        Args:
            update_slots (bool): If ``True`` , `accum` will be updated. Default: ``True`` .

        Inputs:
            - **var** (Union[Parameter, Tensor]) - Variable to be updated. With float or complex data type.
              The shape is :math:`(N, *)` where :math:`*` means, any number of additional dimensions.
            - **accum** (Union[Parameter, Tensor]) - Accumulation to be updated. The shape must be the same as `var`.
            - **lr** (Union[Number, Tensor]) - The learning rate value, must be a scalar. With float or complex data type.
            - **grad** (Tensor) - A tensor for gradient. The shape must be the same as `var`.

        Outputs:
            Tuple of 2 Tensors, the updated parameters or tensors.

            - **var** (Tensor) - The same shape and data type as `var`.
            - **accum** (Tensor) - The same shape and data type as `accum`.

        Raises:
            TypeError: If dtype of `var`, `accum`, `lr` or `grad` is neither float nor complex.
            TypeError: If `lr` is neither a Number nor a Tensor.
            TypeError: If the data type of `var`, `accum` and `grad` conversion of Parameter is not supported.

        Supported Platforms:
            ``Ascend`` ``GPU`` ``CPU``

        Examples:
            >>> import mindspore
            >>> import numpy as np
            >>> from mindspore import Tensor, nn, ops, Parameter
            >>> class Net(nn.Cell):
            ...     def __init__(self):
            ...         super(Net, self).__init__()
            ...         self.apply_adagrad = ops.ApplyAdagrad()
            ...         self.var = Parameter(Tensor(np.array([[0.6, 0.4],
            ...                                               [0.1, 0.5]]).astype(np.float32)), name="var")
            ...         self.accum = Parameter(Tensor(np.array([[0.6, 0.5],
            ...                                                 [0.2, 0.6]]).astype(np.float32)), name="accum")
            ...     def construct(self, lr, grad):
            ...         out = self.apply_adagrad(self.var, self.accum, lr, grad)
            ...         return out
            ...
            >>> net = Net()
            >>> lr = Tensor(0.001, mindspore.float32)
            >>> grad = Tensor(np.array([[0.3, 0.7], [0.1, 0.8]]).astype(np.float32))
            >>> output = net(lr, grad)
            >>> print(output)
            (Tensor(shape=[2, 2], dtype=Float32, value=
            [[ 5.99638879e-01,  3.99296492e-01],
            [ 9.97817814e-02,  4.99281585e-01]]), Tensor(shape=[2, 2], dtype=Float32, value=
            [[ 6.90000057e-01,  9.90000010e-01],
            [ 2.10000008e-01,  1.24000001e+00]]))
