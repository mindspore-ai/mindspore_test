not_equal:
  description: |
    not_equal(self, other) -> Tensor
    
    Computes the non-equivalence of two tensors element-wise.
    
    Note:
        - The `self` and the `other` comply with the implicit type conversion rules to 
          make the data types consistent.
        - When the `other` is a tensor, the shapes of them could be broadcast.
        - When the `other` is a scalar, it could only be a constant.
        - Broadcasting is supported.
    
    .. math::
    
        out_{i} =\begin{cases}
        & \text{True,    if } input_{i} \ne other_{i} \\
        & \text{False,   if } input_{i} = other_{i}
        \end{cases}
    
    Args:
        self (Tensor): A tensor whose data type is number or bool.
        other (Union[Tensor, Number, bool]): The second input is a number or
            a bool when the first input is a tensor or a tensor whose data type is number or bool.
    
    Returns:
        Tensor, the shape is the same as the one after broadcasting,and the data type is bool.
    
    Raises:
        TypeError: If `other` is not one of the following: Tensor, Number, bool.
    
    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``
    
    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> x = Tensor([1, 2, 3], mindspore.float32)
        >>> output = x.not_equal(2.0)
        >>> print(output)
        [ True False True]
        >>>
        >>> x = Tensor([1, 2, 3], mindspore.int32)
        >>> y = Tensor([1, 2, 4], mindspore.int32)
        >>> output = x.not_equal(y)
        >>> print(output)
        [False False True]
