addbmm:
  description: |
    addbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor

    For details, please refer to :func:`mindspore.ops.addbmm`.

    .. method:: Tensor.addbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor
        :noindex:

    Applies batch matrix multiplication to `batch1` and `batch2`, with a reduced add step and add `self` to the result.

    The optional values `alpha` and `beta` are the matrix-matrix product between `batch1` and `batch2` and the scale
    factor for the added tensor `self` respectively. If `beta` is 0, then `self` will be ignored.

    .. math::
        output = \beta self + \alpha (\sum_{i=0}^{b-1} {batch1_i @ batch2_i})

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        batch1 (Tensor): The first batch of tensor to be multiplied.
        batch2 (Tensor): The second batch of tensor to be multiplied.

    Keyword Args:
        beta (Union[int, float], optional): Multiplier for `input`. Default: ``1`` .
        alpha (Union[int, float], optional): Multiplier for `batch1` @ `batch2`. Default: ``1`` .

    Returns:
        Tensor, has the same dtype as `self`.

    Raises:
        TypeError: If `alpha` or `beta` is not an int or float.
        ValueError: If `batch1`, `batch2` cannot apply batch matrix multiplication.
        ValueError: If `batch1` and `batch2` are not 3-D tensors.

    Supported Platforms:
        ``Ascend``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor
        >>> m = np.ones((3, 3)).astype(np.float32)
        >>> arr1 = np.arange(24).astype(np.float32).reshape((2, 3, 4))
        >>> arr2 = np.arange(24).astype(np.float32).reshape((2, 4, 3))
        >>> a = Tensor(arr1)
        >>> b = Tensor(arr2)
        >>> c = Tensor(m)
        >>> output = c.addbmm(a, b)
        >>> print(output)
        [[ 949. 1009. 1069.]
         [1285. 1377. 1469.]
         [1621. 1745. 1869.]]
