addr:
  description: |
    addr(vec1, vec2, *, beta=1, alpha=1) -> Tensor

    Computes the outer product of two vector `vec1` and `vec2`, and adds the resulting matrix to `self`.

    If `vec1` is a vector of size :math:`N`, `vec2` is a vector of size :math:`M`,
    `self` must be able to broadcast to a matrix of shape :math:`(N, M)`.

    `beta` and `alpha` are optional scaling factors for the outer product of `vec1` and `vec2`,
    and the matrix `self` respectively. Setting `beta` to 0 will exclude `self` from the computation.

    .. math::
        output = \beta self + \alpha (vec1 \otimes vec2)

    Args:
        vec1 (Tensor): The first tensor to be multiplied. The shape of the tensor is :math:`(N,)`.
        vec2 (Tensor): The second tensor to be multiplied. The shape of the tensor is :math:`(M,)`.

    Keyword Args:
        beta (scalar[int, float, bool], optional): Multiplier for `self` . The `beta` must be int or
            float or bool. Default: ``1`` .
        alpha (scalar[int, float, bool], optional): Multiplier for :math:`vec1 \otimes vec2` . The `alpha` must
            be int or float or bool. Default: ``1`` .

    Returns:
        Tensor, the shape of the output tensor is :math:`(N, M)`, has the same dtype as `self`.

    Raises:
        TypeError: If `self`, `vec1` or `vec2` is not a Tensor.
        TypeError: If `vec1` and `vec2` are not the same dtype.
        ValueError: If `vec1` or `vec2` is not a 1-D Tensor.

    Supported Platforms:
        ``Ascend``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor
        >>> x = Tensor(np.array([[2., 2.], [3., 2.], [3., 4.]], np.float32))
        >>> vec1 = Tensor(np.array([2., 3., 2.], np.float32))
        >>> vec2 = Tensor(np.array([3, 4], np.float32))
        >>> output = x.addr(vec1, vec2)
        >>> print(output)
        [[ 8. 10.]
         [12. 14.]
         [ 9. 12.]]
